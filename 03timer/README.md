# timer 延时任务系统 --四叉树，消息队列 MQ 设置集群

```text
比如通知、发券等等。
一般有两种思路来解决这个问题：
1.实现一套类似 crontab 的分布式定时任务管理系统。
2.实现一个支持定时发送消息的消息队列。
两种思路进而衍生出了一些不同的系统，但其本质是差不多的。
都是需要实现一个定时器。定时器英文为 timer
```

### 1 timer 实现
```text
timer 的实现在工业界已经是有解的问题了。
常见的就是时间堆和时间轮。
1 时间堆
    Go 自身的 timer 就是用时间堆来实现的，不过并没有使用二叉堆，而是使用了扁平一些的四叉堆。
    小顶堆的性质，父节点比其 4 个子节点都小，子节点之间没有特别的大小关系要求。    
    四叉堆中元素超时和堆调整与二叉堆没有什么本质区别。
                                                             +-----+
                                                             |     |
                                                             |  0  |
                                                             +-----+
                                                                |
                                                                |
                                                                |
                                                                v
                                                    +-----+-----+-----+-----+
                                                    |     |     |     |     |
                                                    |  3  |  2  |  2  |  10 |
                                                    +-----+-----+-----+-----+
                                                       |     |     |     |
                                                       |     |     |     |
                    +----------+                       |     |     |     |
   +----------------+  4*i+1   +-----------------------+     |     |     +-----------------------------+
   |                +----------+         +-------------------+     +---+                               |
   |                                     |                             |                               |
   |                                     |                             |                               |
   v                                     |                             |                               v
+-----+-----+-----+-----+                |                             |                            +-----+-----+-----+-----+
|     |     |     |     |                v                             v                            |     |     |     |     |
|  20 |  4  |  5  |  13 |             +-----+-----+-----+-----+     +-----+-----+-----+-----+       | 99  | 13  | 11  |  12 |
+-----+-----+-----+-----+             |     |     |     |     |     |     |     |     |     |       +-----+-----+-----+-----+
                                      | 12  | 14  | 15  |  16 |     | 3   | 10  | 3   |  3  |
                                      +-----+-----+-----+-----+     +-----+-----+-----+-----+
2 时间轮
    用时间轮来实现 timer 时，我们需要定义每一个格子的“刻度”，
    可以将时间轮想像成一个时钟，中心有秒针顺时针转动。每次转动到一个刻度时，
    我们就需要去查看该刻度挂载的 tasklist 是否有已经到期的任务。
    从结构上来讲，时间轮和哈希表很相似，如果我们把哈希算法定义为：触发时间%时间轮元素大小。
    那么这就是一个简单的哈希表。在哈希冲突时，采用链表挂载哈希冲突的定时器。
```

### 2 任务分发
```text
我们需要把这些“定时”或是“延时”(本质也是定时)任务分发出去。下面是一种思路：
见图“images/”

每一个实例每隔一小时，会去数据库里把下一个小时需要处理的定时任务捞出来，捞取的时候只要取那些
 task_id % shard_count = shard_id 的那些 task 即可。

当这些定时任务被触发之后需要通知用户侧，有两种思路：
    1.将任务被触发的信息封装为一条 event 消息，发往消息队列，由用户侧对消息队列进行监听。
    2.对用户预先配置的回调函数进行调用。
两种方案各有优缺点:
    1，那么如果消息队列出故障会导致整个系统不可用，当然，现在的消息队列一般也会有自身的高可用方案，
    大多数时候我们不用担心这个问题。其次一般业务流程中间走消息队列的话会导致延时增加，
    定时任务若必须在触发后的几十毫秒到几百毫秒内完成，那么采用消息队列就会有一定的风险。 
    2，会加重定时任务系统的负担。我们知道，单机的 timer 执行时最害怕的就是回调函数执行时间过长，
    这样会阻塞后续的任务执行。在分布式场景下，这种忧虑依然是适用的。
    一个不负责任的业务回调可能就会直接拖垮整个定时任务系统。
    所以我们还要考虑在回调的基础上增加经过测试的超时时间设置，并且对由用户填入的超时时间做慎重的审核。
```

### 3 rebalance 和幂等考量
```text
当我们的任务执行集群有机器故障时，需要对任务进行重新分配。
下面给出一种思路：
    参考 elasticsearch 的设计，每份任务数据都有多个副本(跟etcd，kafka的leader,follwer一样)
    当有机器故障时，任务数据需要进行 rebalance 工作，比如 node 1 挂了：node 1 的数据会被迁移到 node 2 和 node 3 上。
    当然，也可以用稍微复杂一些的思路，比如对集群中的节点进行角色划分，
    由协调节点来做这种故障时的任务重新分配工作，考虑到高可用，协调节点可能也需要有 1 ~ 2 个备用节点以防不测。
之前提到我们会用 MQ 触发对用户的通知，在使用 MQ 时，
很多 MQ 是不支持 exactly once 的语义的，这种情况下我们需要让用户自己来负责消息的去重或者消费的幂等处理。
```

