#Load-Balance 负载均衡  ----shuffle算法, fisher yates 算法, rand.Seed(time.Now().UnixNano())

### 1.常见的负载均衡思路
```text
1.按顺序挑: 例如上次选了第一台，那么这次就选第二台，下次第三台，如果已经到了最后一台，
  那么下一次从第一台开始。这种情况下我们可以把 endpoint 都存储在数组中，每次请求完成下游之后，
  将一个索引后移即可。在移到尽头时再移回数组开头处。
2.随机挑一个: 每次都随机挑，真随机伪随机均可。假设选择第 x 台机器，那么 x 可描述为 rand.Intn() % n。
3.根据某种权重，对下游 endpoints 进行排序，选择权重最大/小的那一个。
当然了，实际场景我们不可能无脑轮询或者无脑随机，如果对下游请求失败了，
我们还需要某种机制来进行重试，如果纯粹的随机算法，存在一定的可能性使你在下一次仍然随机到这次的问题节点。
```

### 2.基于洗牌算法的负载均衡 --shuffle算法  fisher yates 算法
```text
考虑到我们需要随机选取每次发送请求的 endpoint，同时在遇到下游返回错误时换其它节点重试。
所以我们设计一个大小和 endpoints 数组大小一致的索引数组，每次来新的请求，我们对索引数组做洗牌，
然后取第一个元素作为选中的服务节点，如果请求失败，那么选择下一个节点重试，以此类推:
我们循环一遍 slice，两两交换，这个和我们平常打牌时常用的洗牌方法类似。看起来没有什么问题。
01balace.go
1.错误的洗牌导致的负载不均衡
    出现的问题：
    1.没有随机种子。在没有随机种子的情况下，rand.Intn 返回的伪随机数序列是固定的。
    2.洗牌不均匀，会导致整个数组第一个节点有大概率被选中，并且多个节点的负载分布不均衡。

2 修正洗牌算法
    从数学上得到过证明的还是经典的 fisher-yates 算法，主要思路为每次随机挑选一个值，放在数组末尾。
    然后在 n-1 个元素的数组中再随机挑选一个值，放在数组末尾，以此类推。
    在当前的场景下，我们只要用 Go 的 rand.Perm 就可以得到我们想要的索引数组了。
3. zk 集群的随机节点挑选问题
    例如使用 zk 时，客户端初始化从多个服务节点中挑选一个节点后，是会向该节点建立长连接的。
    并且之后如果有请求，也都会发送到该节点去。直到该节点不可用，才会在 endpoints 列表中挑选下一个节点。
    在这种场景下，我们的初始连接节点选择就要求必须是“真”随机了。否则，所有客户端起动时，
    都会去连接同一个 zk 的实例，根本无法起到负载均衡的目的。如果在日常开发中，你的业务也是类似的场景，
    也务必考虑一下是否会发生类似的情况。为 rand 库设置种子的方法:
    rand.Seed(time.Now().UnixNano())
4.负载均衡算法效果验证
    我们这里不考虑加权负载均衡的情况，既然名字是负载“均衡”。那么最重要的就是均衡。
    我们把开篇中的 shuffle 算法，和之后的 fisher yates 算法的结果进行简单地对比：
    02balance.go
    分布结果和我们推导出的结论是一致的。
```